# Rakefile generated by Stackhammer.RakeOrchestratorBuilder
# Executes a sequence of rakefiles

require 'fileutils.rb'
require 'pathname.rb'

# path to root of repository containing puppet logic
REPOROOT = '/tmp/whatever'

# path to root of payload (extra files passed to test execution server)
PAYLOAD = '/tmp/payload'

# root of where a rakefile execution should copy its result to
RESULTROOT = '/tmp/results'
FileUtils.mkdir_p(RESULTROOT)

INJECTEDFACTS = File.join('', 'tmp', 'stackhammer', 'testing', 'facts.yaml')

# Describes what to do with a result set
class ResultProcessing
   attr_accessor :steps
   def initialize()
       @steps = []
   end
   def copy(root, relative, name)
       @steps << CopyStep.new(root, relative, name)
   end
   def process()
       @steps.each { |s| s.process() }
   end
end
# Describes a copy processing step
class CopyStep < Struct.new(:root, :relative, :name)
    def process()
       base = Pathname.new(File.join(root, relative))
       junitfiles = File.join(base, '**', '*.xml')
       Dir.glob(junitfiles) do |f|
           resultRelative = Pathname.new(f).relative_path_from(base)
           target = File.join(RESULTROOT, name, resultRelative)
           # target directory must exist
           FileUtils.mkdir_p(File.dirname(target))
           FileUtils.cp(f, target)
       end
    end
end
# Describes each rake run result and produces Junit report of runs.
class RakeResult
    attr_accessor :fname, :duration, :status, :capture
    # collects rake_run_results here
    @@rake_run_results = []
    @@tests = 0
    @@errors = 0
    def initialize(fname, duration, status, capture=nil)
        @fname = fname
        @duration = duration
        @status = status
        @capture = capture
        @@rake_run_results << self
        @@tests += 1
        @@errors += (status != 0 or status.kind_of?(Exception)) ? 1 : 0
    end
    def status_msg()
        case @status
        when Exception
            "Exception: #{@status.message}"
        else
            "Rake exit status: #{@status}"
        end
    end
    def self.report_as_junit(file_name)
        File.open(file_name, "w+") do |f|
            f.puts(%[<?xml version="1.0" encoding="UTF-8" ?>])
            f.puts(%[<testsuite name="rakeruns" tests="#{ @@tests }" errors="#{ @@errors }">])
            @@rake_run_results.each do |r|
                f.puts(%[  <testcase name="#{r.fname}" time="#{r.duration}" #{r.status == 0 ? '>' : '/>'}])
                if r.status != 0
                     f.puts(%[    <error message="#{r.status_msg}" #{r.capture.nil? ? '/>' : '>'}])
                     if !r.capture.nil?
                         f.puts("    <![CDATA[#{r.capture}]]>")
                         f.puts("    </error>")
                     end
                     f.puts(%[  </testcase>])
                end
            end
            f.puts(%[</testsuite>])
        end
    end
end

# Runs rake on rakefile and processes error or copy of result
def run_rake (root_dir, rakefile_path, task_name, result_processing, facts = nil)
    rf = File.join(root_dir, rakefile_path)
    # time now in seconds and ms
    time1 = Time.now.to_f
    begin
        # ensure injected facts directory exists
        FileUtils.mkdir_p(File.dirname(INJECTEDFACTS))
        # remove any old facts
        File.delete(INJECTEDFACTS) if File.exists?(INJECTEDFACTS)
        # inject facts if given
        FileUtils.copy(facts, INJECTEDFACTS) unless facts.nil?
        Dir.chdir(File.dirname(rf))
        # rake in subshell, get stdout/err as one string
        capture = %x{rake #{task_name} 2>&1}
        status = $?.exitstatus
        # duration in seconds and ms
        duration = Time.now.to_f - time1
        if status == 0 && !result_processing.nil?
            result_processing.process()
        end
        # add report irrespective of outcome
        RakeResult.new(rakefile_path, duration, status, capture)
    rescue => e
        # log exception as result if run/processing fails
        RakeResult.new(rakefile_path, 0.0, e)
        return
    end
end
task :test0 do |t|
    rp = ResultProcessing.new()
    run_rake(REPOROOT, 'thisdir/Rakefile', 'thisTask', rp, File.join(REPOROOT, 'facts/facts1'))
end

task :test1 do |t|
    rp = ResultProcessing.new()
    run_rake(REPOROOT, 'thatdir/Rakefile', 'thatTask', rp, nil)
end

task :test2 do |t|
    rp = ResultProcessing.new()
    rp.copy(REPOROOT, 'okDir', 'okSet')
    run_rake(REPOROOT, 'okdir/Rakefile', 'okTask', rp, nil)
end

task :runall => [:test0, :test1, :test2] do
    # executed after all other tasks - produces result report per rakefile
    RakeResult.report_as_junit(File.join(RESULTROOT, 'rakerunner'))
end

task :default => :runall
